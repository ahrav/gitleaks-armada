// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: enumeration.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :exec
WITH core_task AS (
    INSERT INTO tasks (task_id, source_type)
    VALUES ($1, $2)
    RETURNING task_id
)
INSERT INTO enumeration_tasks (
    task_id,
    session_id,
    resource_uri,
    metadata
) VALUES (
    (SELECT task_id FROM core_task),
    $3,
    $4,
    $5
)
`

type CreateTaskParams struct {
	TaskID      pgtype.UUID
	SourceType  string
	SessionID   pgtype.UUID
	ResourceUri string
	Metadata    []byte
}

// ============================================
// Enumeration Tasks
// ============================================
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.TaskID,
		arg.SourceType,
		arg.SessionID,
		arg.ResourceUri,
		arg.Metadata,
	)
	return err
}

const deleteCheckpoint = `-- name: DeleteCheckpoint :exec
DELETE FROM checkpoints
WHERE target_id = $1
`

func (q *Queries) DeleteCheckpoint(ctx context.Context, targetID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCheckpoint, targetID)
	return err
}

const deleteEnumerationSessionState = `-- name: DeleteEnumerationSessionState :exec
DELETE FROM enumeration_session_states
WHERE session_id = $1
`

func (q *Queries) DeleteEnumerationSessionState(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEnumerationSessionState, sessionID)
	return err
}

const getActiveEnumerationSessionStates = `-- name: GetActiveEnumerationSessionStates :many
SELECT id, session_id, source_type, config, last_checkpoint_id, failure_reason,
       status, created_at, updated_at
FROM enumeration_session_states
WHERE status IN ('INITIALIZED', 'IN_PROGRESS')
ORDER BY created_at DESC
`

type GetActiveEnumerationSessionStatesRow struct {
	ID               int64
	SessionID        pgtype.UUID
	SourceType       string
	Config           []byte
	LastCheckpointID pgtype.Int8
	FailureReason    pgtype.Text
	Status           EnumerationStatus
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) GetActiveEnumerationSessionStates(ctx context.Context) ([]GetActiveEnumerationSessionStatesRow, error) {
	rows, err := q.db.Query(ctx, getActiveEnumerationSessionStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveEnumerationSessionStatesRow
	for rows.Next() {
		var i GetActiveEnumerationSessionStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SourceType,
			&i.Config,
			&i.LastCheckpointID,
			&i.FailureReason,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatch = `-- name: GetBatch :one
SELECT id, batch_id, session_id, status, checkpoint_id, started_at, completed_at, last_update, items_processed, expected_items, error_details, created_at, updated_at FROM enumeration_batches
WHERE batch_id = $1
`

func (q *Queries) GetBatch(ctx context.Context, batchID pgtype.UUID) (EnumerationBatch, error) {
	row := q.db.QueryRow(ctx, getBatch, batchID)
	var i EnumerationBatch
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.SessionID,
		&i.Status,
		&i.CheckpointID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastUpdate,
		&i.ItemsProcessed,
		&i.ExpectedItems,
		&i.ErrorDetails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBatchesForSession = `-- name: GetBatchesForSession :many
SELECT id, batch_id, session_id, status, checkpoint_id, started_at, completed_at, last_update, items_processed, expected_items, error_details, created_at, updated_at
FROM enumeration_batches
WHERE session_id = $1
ORDER BY started_at ASC
`

func (q *Queries) GetBatchesForSession(ctx context.Context, sessionID pgtype.UUID) ([]EnumerationBatch, error) {
	rows, err := q.db.Query(ctx, getBatchesForSession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnumerationBatch
	for rows.Next() {
		var i EnumerationBatch
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.SessionID,
			&i.Status,
			&i.CheckpointID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastUpdate,
			&i.ItemsProcessed,
			&i.ExpectedItems,
			&i.ErrorDetails,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCheckpoint = `-- name: GetCheckpoint :one
SELECT id, target_id, data, created_at, updated_at
FROM checkpoints
WHERE target_id = $1
`

func (q *Queries) GetCheckpoint(ctx context.Context, targetID pgtype.UUID) (Checkpoint, error) {
	row := q.db.QueryRow(ctx, getCheckpoint, targetID)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.TargetID,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCheckpointByID = `-- name: GetCheckpointByID :one
SELECT id, target_id, data, created_at, updated_at
FROM checkpoints
WHERE id = $1
`

func (q *Queries) GetCheckpointByID(ctx context.Context, id int64) (Checkpoint, error) {
	row := q.db.QueryRow(ctx, getCheckpointByID, id)
	var i Checkpoint
	err := row.Scan(
		&i.ID,
		&i.TargetID,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEnumerationSessionState = `-- name: GetEnumerationSessionState :one
SELECT id, session_id, source_type, config, last_checkpoint_id, status, failure_reason, started_at, completed_at, last_update, created_at, updated_at FROM enumeration_session_states
WHERE session_id = $1
`

func (q *Queries) GetEnumerationSessionState(ctx context.Context, sessionID pgtype.UUID) (EnumerationSessionState, error) {
	row := q.db.QueryRow(ctx, getEnumerationSessionState, sessionID)
	var i EnumerationSessionState
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SourceType,
		&i.Config,
		&i.LastCheckpointID,
		&i.Status,
		&i.FailureReason,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionMetrics = `-- name: GetSessionMetrics :one
SELECT id, session_id, total_batches, failed_batches, items_found, items_processed, created_at, updated_at FROM enumeration_session_metrics
WHERE session_id = $1
`

func (q *Queries) GetSessionMetrics(ctx context.Context, sessionID pgtype.UUID) (EnumerationSessionMetric, error) {
	row := q.db.QueryRow(ctx, getSessionMetrics, sessionID)
	var i EnumerationSessionMetric
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.TotalBatches,
		&i.FailedBatches,
		&i.ItemsFound,
		&i.ItemsProcessed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionState = `-- name: GetSessionState :one
SELECT id, session_id, source_type, config, last_checkpoint_id, status, failure_reason, started_at, completed_at, last_update, created_at, updated_at FROM enumeration_session_states
WHERE session_id = $1
`

func (q *Queries) GetSessionState(ctx context.Context, sessionID pgtype.UUID) (EnumerationSessionState, error) {
	row := q.db.QueryRow(ctx, getSessionState, sessionID)
	var i EnumerationSessionState
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SourceType,
		&i.Config,
		&i.LastCheckpointID,
		&i.Status,
		&i.FailureReason,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastUpdate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT
    t.task_id,
    t.source_type,
    et.session_id,
    et.resource_uri,
    et.metadata,
    et.created_at,
    et.updated_at
FROM tasks t
JOIN enumeration_tasks et ON t.task_id = et.task_id
WHERE t.task_id = $1
`

type GetTaskByIDRow struct {
	TaskID      pgtype.UUID
	SourceType  string
	SessionID   pgtype.UUID
	ResourceUri string
	Metadata    []byte
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) GetTaskByID(ctx context.Context, taskID pgtype.UUID) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, taskID)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.TaskID,
		&i.SourceType,
		&i.SessionID,
		&i.ResourceUri,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEnumerationSessionStates = `-- name: ListEnumerationSessionStates :many
SELECT id, session_id, source_type, config, last_checkpoint_id, failure_reason,
       status, created_at, updated_at
FROM enumeration_session_states
ORDER BY created_at DESC
LIMIT $1
`

type ListEnumerationSessionStatesRow struct {
	ID               int64
	SessionID        pgtype.UUID
	SourceType       string
	Config           []byte
	LastCheckpointID pgtype.Int8
	FailureReason    pgtype.Text
	Status           EnumerationStatus
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) ListEnumerationSessionStates(ctx context.Context, limit int32) ([]ListEnumerationSessionStatesRow, error) {
	rows, err := q.db.Query(ctx, listEnumerationSessionStates, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnumerationSessionStatesRow
	for rows.Next() {
		var i ListEnumerationSessionStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SourceType,
			&i.Config,
			&i.LastCheckpointID,
			&i.FailureReason,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBatch = `-- name: UpsertBatch :exec
INSERT INTO enumeration_batches (
   batch_id,
   session_id,
   status,
   checkpoint_id,
   started_at,
   completed_at,
   last_update,
   items_processed,
   expected_items,
   error_details
) VALUES (
   $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (batch_id) DO UPDATE SET
   status = EXCLUDED.status,
   checkpoint_id = EXCLUDED.checkpoint_id,
   completed_at = EXCLUDED.completed_at,
   last_update = EXCLUDED.last_update,
   items_processed = EXCLUDED.items_processed,
   error_details = EXCLUDED.error_details,
   updated_at = NOW()
`

type UpsertBatchParams struct {
	BatchID        pgtype.UUID
	SessionID      pgtype.UUID
	Status         BatchStatus
	CheckpointID   pgtype.Int8
	StartedAt      pgtype.Timestamptz
	CompletedAt    pgtype.Timestamptz
	LastUpdate     pgtype.Timestamptz
	ItemsProcessed int32
	ExpectedItems  int32
	ErrorDetails   pgtype.Text
}

// ============================================
// Batch (Entity) operations
// ============================================
func (q *Queries) UpsertBatch(ctx context.Context, arg UpsertBatchParams) error {
	_, err := q.db.Exec(ctx, upsertBatch,
		arg.BatchID,
		arg.SessionID,
		arg.Status,
		arg.CheckpointID,
		arg.StartedAt,
		arg.CompletedAt,
		arg.LastUpdate,
		arg.ItemsProcessed,
		arg.ExpectedItems,
		arg.ErrorDetails,
	)
	return err
}

const upsertCheckpoint = `-- name: UpsertCheckpoint :one

INSERT INTO checkpoints (target_id, data, created_at, updated_at)
VALUES ($1, $2, NOW(), NOW())
ON CONFLICT (target_id) DO UPDATE
    SET data = EXCLUDED.data,
        updated_at = NOW()
RETURNING id
`

type UpsertCheckpointParams struct {
	TargetID pgtype.UUID
	Data     []byte
}

// Enumeration Domain Queries
// ============================================
// Checkpoints
// ============================================
func (q *Queries) UpsertCheckpoint(ctx context.Context, arg UpsertCheckpointParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertCheckpoint, arg.TargetID, arg.Data)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertEnumerationSessionState = `-- name: UpsertEnumerationSessionState :exec
INSERT INTO enumeration_session_states (
    session_id, source_type, config, last_checkpoint_id, status, failure_reason
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (session_id) DO UPDATE
SET source_type = EXCLUDED.source_type,
    config = EXCLUDED.config,
    last_checkpoint_id = EXCLUDED.last_checkpoint_id,
    status = EXCLUDED.status,
    failure_reason = EXCLUDED.failure_reason,
    updated_at = NOW()
`

type UpsertEnumerationSessionStateParams struct {
	SessionID        pgtype.UUID
	SourceType       string
	Config           []byte
	LastCheckpointID pgtype.Int8
	Status           EnumerationStatus
	FailureReason    pgtype.Text
}

// ============================================
// Enumeration States
// ============================================
func (q *Queries) UpsertEnumerationSessionState(ctx context.Context, arg UpsertEnumerationSessionStateParams) error {
	_, err := q.db.Exec(ctx, upsertEnumerationSessionState,
		arg.SessionID,
		arg.SourceType,
		arg.Config,
		arg.LastCheckpointID,
		arg.Status,
		arg.FailureReason,
	)
	return err
}

const upsertSessionMetrics = `-- name: UpsertSessionMetrics :exec
INSERT INTO enumeration_session_metrics (
   session_id,
   total_batches,
   failed_batches,
   items_found,
   items_processed
) VALUES (
   $1, $2, $3, $4, $5
)
ON CONFLICT (session_id) DO UPDATE SET
   total_batches = EXCLUDED.total_batches,
   failed_batches = EXCLUDED.failed_batches,
   items_found = EXCLUDED.items_found,
   items_processed = EXCLUDED.items_processed,
   updated_at = NOW()
`

type UpsertSessionMetricsParams struct {
	SessionID      pgtype.UUID
	TotalBatches   int32
	FailedBatches  int32
	ItemsFound     int32
	ItemsProcessed int32
}

func (q *Queries) UpsertSessionMetrics(ctx context.Context, arg UpsertSessionMetricsParams) error {
	_, err := q.db.Exec(ctx, upsertSessionMetrics,
		arg.SessionID,
		arg.TotalBatches,
		arg.FailedBatches,
		arg.ItemsFound,
		arg.ItemsProcessed,
	)
	return err
}

const upsertSessionState = `-- name: UpsertSessionState :exec
INSERT INTO enumeration_session_states (
   session_id,
   source_type,
   config,
   status,
   failure_reason,
   last_checkpoint_id,
   started_at,
   completed_at,
   last_update
) VALUES (
   $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (session_id) DO UPDATE SET
   status = EXCLUDED.status,
   failure_reason = EXCLUDED.failure_reason,
   last_checkpoint_id = EXCLUDED.last_checkpoint_id,
   completed_at = EXCLUDED.completed_at,
   last_update = EXCLUDED.last_update,
   updated_at = NOW()
`

type UpsertSessionStateParams struct {
	SessionID        pgtype.UUID
	SourceType       string
	Config           []byte
	Status           EnumerationStatus
	FailureReason    pgtype.Text
	LastCheckpointID pgtype.Int8
	StartedAt        pgtype.Timestamptz
	CompletedAt      pgtype.Timestamptz
	LastUpdate       pgtype.Timestamptz
}

// ============================================
// Session State and Metrics operations
// ============================================
func (q *Queries) UpsertSessionState(ctx context.Context, arg UpsertSessionStateParams) error {
	_, err := q.db.Exec(ctx, upsertSessionState,
		arg.SessionID,
		arg.SourceType,
		arg.Config,
		arg.Status,
		arg.FailureReason,
		arg.LastCheckpointID,
		arg.StartedAt,
		arg.CompletedAt,
		arg.LastUpdate,
	)
	return err
}
