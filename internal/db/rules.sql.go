// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertAllowlistCommitsParams struct {
	AllowlistID int64
	Commit      string
}

type BulkInsertAllowlistPathsParams struct {
	AllowlistID int64
	Path        string
}

type BulkInsertAllowlistRegexesParams struct {
	AllowlistID int64
	Regex       string
}

type BulkInsertAllowlistStopwordsParams struct {
	AllowlistID int64
	Stopword    string
}

type BulkInsertAllowlistsParams struct {
	RuleID         int64
	Description    pgtype.Text
	MatchCondition string
	RegexTarget    pgtype.Text
}

type BulkInsertRulesParams struct {
	RuleID      string
	Description pgtype.Text
	Entropy     pgtype.Float8
	SecretGroup pgtype.Int4
	Regex       string
	Path        pgtype.Text
	Tags        []string
	Keywords    []string
}

const deleteAllowlistCommits = `-- name: DeleteAllowlistCommits :exec
DELETE FROM allowlist_commits WHERE allowlist_id = $1
`

// ============================================
// Allowlist Commits
// ============================================
func (q *Queries) DeleteAllowlistCommits(ctx context.Context, allowlistID int64) error {
	_, err := q.db.Exec(ctx, deleteAllowlistCommits, allowlistID)
	return err
}

const deleteAllowlistPaths = `-- name: DeleteAllowlistPaths :exec
DELETE FROM allowlist_paths WHERE allowlist_id = $1
`

// ============================================
// Allowlist Paths
// ============================================
func (q *Queries) DeleteAllowlistPaths(ctx context.Context, allowlistID int64) error {
	_, err := q.db.Exec(ctx, deleteAllowlistPaths, allowlistID)
	return err
}

const deleteAllowlistRegexes = `-- name: DeleteAllowlistRegexes :exec
DELETE FROM allowlist_regexes WHERE allowlist_id = $1
`

// ============================================
// Allowlist Regexes
// ============================================
func (q *Queries) DeleteAllowlistRegexes(ctx context.Context, allowlistID int64) error {
	_, err := q.db.Exec(ctx, deleteAllowlistRegexes, allowlistID)
	return err
}

const deleteAllowlistStopwords = `-- name: DeleteAllowlistStopwords :exec
DELETE FROM allowlist_stopwords WHERE allowlist_id = $1
`

// ============================================
// Allowlist Stopwords
// ============================================
func (q *Queries) DeleteAllowlistStopwords(ctx context.Context, allowlistID int64) error {
	_, err := q.db.Exec(ctx, deleteAllowlistStopwords, allowlistID)
	return err
}

const upsertAllowlist = `-- name: UpsertAllowlist :one
INSERT INTO allowlists (
    rule_id, description, match_condition, regex_target
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (rule_id, match_condition, regex_target) DO UPDATE
SET description = EXCLUDED.description,
    updated_at = NOW()
RETURNING id
`

type UpsertAllowlistParams struct {
	RuleID         int64
	Description    pgtype.Text
	MatchCondition string
	RegexTarget    pgtype.Text
}

// ============================================
// Allowlists
// ============================================
func (q *Queries) UpsertAllowlist(ctx context.Context, arg UpsertAllowlistParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertAllowlist,
		arg.RuleID,
		arg.Description,
		arg.MatchCondition,
		arg.RegexTarget,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertRule = `-- name: UpsertRule :one

INSERT INTO rules (
    rule_id, description, entropy, secret_group, regex, path, tags, keywords
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (rule_id) DO UPDATE
SET description = EXCLUDED.description,
    entropy = EXCLUDED.entropy,
    secret_group = EXCLUDED.secret_group,
    regex = EXCLUDED.regex,
    path = EXCLUDED.path,
    tags = EXCLUDED.tags,
    keywords = EXCLUDED.keywords,
    updated_at = NOW()
RETURNING id
`

type UpsertRuleParams struct {
	RuleID      string
	Description pgtype.Text
	Entropy     pgtype.Float8
	SecretGroup pgtype.Int4
	Regex       string
	Path        pgtype.Text
	Tags        []string
	Keywords    []string
}

// Rules Domain Queries
// ============================================
// Rules
// ============================================
func (q *Queries) UpsertRule(ctx context.Context, arg UpsertRuleParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertRule,
		arg.RuleID,
		arg.Description,
		arg.Entropy,
		arg.SecretGroup,
		arg.Regex,
		arg.Path,
		arg.Tags,
		arg.Keywords,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
