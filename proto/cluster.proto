syntax = "proto3";

package cluster;

option go_package = "github.com/ahrav/gitleaks-armada/proto;cluster";

// Common types.
message NodeInfo {
  string id = 1;
  string endpoint = 2; // Could be host:port or DNS name
  map<string, string> metadata = 3;
}

enum HealthStatus {
  UNKNOWN = 0;
  HEALTHY = 1;
  UNHEALTHY = 2;
}

message WorkerCapacity { int32 max_concurrent_tasks = 1; }

message WorkerInfo {
  string id = 1;
  string endpoint = 2;
  map<string, string> metadata = 3;
  WorkerCapacity capacity = 4;
}

message WorkerStatus {
  string worker_id = 1;
  HealthStatus status = 2;
  // Additional fields like last_heartbeat, current_tasks, etc.
}

message ScanTask {
  string task_id = 1;
  string repo_url = 2;
  string commit_sha = 3;
  // Add other fields such as chunking info, scanning rules references, etc.
}

message Finding {
  string rule_id = 1;
  string secret = 2;
  string location = 3; // file path, line number, etc.
}

message TaskFilter {
  repeated string status_in = 1;
  // For example: ["pending", "in_progress"] or ["complete"]
}

//
// ClusterManagementService
//
service ClusterManagementService {
  rpc ElectLeader(ElectLeaderRequest) returns (ElectLeaderResponse);
  rpc IsLeader(IsLeaderRequest) returns (IsLeaderResponse);
  rpc GetLeader(GetLeaderRequest) returns (GetLeaderResponse);

  // You might omit OnLeadershipChange from the proto directly since callbacks
  // are tricky with gRPC. Instead, you can use streaming or polling strategies:
  // rpc WatchLeadership(WatchLeadershipRequest) returns (stream
  // LeadershipEvent);
}

message ElectLeaderRequest {}
message ElectLeaderResponse { bool became_leader = 1; }

message IsLeaderRequest {}
message IsLeaderResponse { bool is_leader = 1; }

message GetLeaderRequest {}
message GetLeaderResponse { NodeInfo leader_node = 1; }

//
// NodeRegistryService
//
service NodeRegistryService {
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeResponse);
  rpc UnregisterNode(UnregisterNodeRequest) returns (UnregisterNodeResponse);
  rpc GetNodes(GetNodesRequest) returns (GetNodesResponse);

  rpc ReportHealth(ReportHealthRequest) returns (ReportHealthResponse);
  rpc GetNodeHealth(GetNodeHealthRequest) returns (GetNodeHealthResponse);

  // Similarly, for workers, you could have:
  rpc RegisterWorker(RegisterWorkerRequest) returns (RegisterWorkerResponse);
  rpc UnregisterWorker(UnregisterWorkerRequest)
      returns (UnregisterWorkerResponse);
  rpc GetAvailableWorkers(GetAvailableWorkersRequest)
      returns (GetAvailableWorkersResponse);
  rpc UpdateWorkerStatus(UpdateWorkerStatusRequest)
      returns (UpdateWorkerStatusResponse);
  rpc GetWorkerStatus(GetWorkerStatusRequest) returns (GetWorkerStatusResponse);
}

// Node registry messages
message RegisterNodeRequest { NodeInfo node = 1; }
message RegisterNodeResponse {}

message UnregisterNodeRequest { string node_id = 1; }
message UnregisterNodeResponse {}

message GetNodesRequest {}
message GetNodesResponse { repeated NodeInfo nodes = 1; }

message ReportHealthRequest {
  string node_id = 1;
  HealthStatus status = 2;
}
message ReportHealthResponse {}

message GetNodeHealthRequest { string node_id = 1; }
message GetNodeHealthResponse { HealthStatus status = 1; }

// Worker registry messages
message RegisterWorkerRequest { WorkerInfo worker = 1; }
message RegisterWorkerResponse {}

message UnregisterWorkerRequest { string worker_id = 1; }
message UnregisterWorkerResponse {}

message GetAvailableWorkersRequest {}
message GetAvailableWorkersResponse { repeated WorkerInfo workers = 1; }

message UpdateWorkerStatusRequest { WorkerStatus status = 1; }
message UpdateWorkerStatusResponse {}

message GetWorkerStatusRequest { string worker_id = 1; }
message GetWorkerStatusResponse { WorkerStatus status = 1; }

//
// StorageService
//
service StorageService {
  // Task management
  rpc SaveTask(SaveTaskRequest) returns (SaveTaskResponse);
  rpc GetTask(GetTaskRequest) returns (GetTaskResponse);
  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);

  // Results management
  rpc SaveFindings(SaveFindingsRequest) returns (SaveFindingsResponse);
  rpc GetFindings(GetFindingsRequest) returns (GetFindingsResponse);

  // State management (for arbitrary key-value state)
  rpc SaveState(SaveStateRequest) returns (SaveStateResponse);
  rpc GetState(GetStateRequest) returns (GetStateResponse);
}

// Storage messages
message SaveTaskRequest { ScanTask task = 1; }
message SaveTaskResponse {}

message GetTaskRequest { string task_id = 1; }
message GetTaskResponse { ScanTask task = 1; }

message ListTasksRequest { TaskFilter filter = 1; }
message ListTasksResponse { repeated ScanTask tasks = 1; }

message SaveFindingsRequest {
  string task_id = 1;
  repeated Finding findings = 2;
}
message SaveFindingsResponse {}

message GetFindingsRequest { string task_id = 1; }
message GetFindingsResponse { repeated Finding findings = 1; }

message SaveStateRequest {
  string key = 1;
  bytes value = 2;
}
message SaveStateResponse {}

message GetStateRequest { string key = 1; }
message GetStateResponse { bytes value = 1; }
