syntax = "proto3";

package scanner;

import "google/protobuf/struct.proto";

option go_package = "github.com/ahrav/gitleaks-armada/proto/scanner;scanner";

// A universal envelope containing the actual domain event type
// and its serialized bytes.
message UniversalEnvelope {
  string event_type = 1; // e.g. "TaskStarted", "TaskProgressed", etc.
  bytes payload = 2;     // serialized domain event data
}

enum SourceType {
  SOURCE_TYPE_UNSPECIFIED = 0;
  SOURCE_TYPE_GITHUB = 1;
  SOURCE_TYPE_S3 = 2;
  SOURCE_TYPE_URL = 3;
}

message EnumerationTask {
  string task_id = 1;
  SourceType source_type = 2;
  string job_id = 3;
  string session_id = 4;
  string resource_uri = 5; // e.g., "git://github.com/org/repo"
  map<string, string> metadata = 6;
  TaskCredentials credentials = 7;
}

message BatchEnumerationTask { repeated EnumerationTask tasks = 1; }

// The final outcome of a scan, containing all discovered findings, status, etc.
message ScanResult {
  // Ties back to the ScanTask this result belongs to.
  string task_id = 1;
  // All secrets or matches found during this scan.
  repeated Finding findings = 2;
  // Status of this job, matching your DB enum.
  ScanJobStatus status = 3;
  // If status == SCAN_JOB_STATUS_FAILED, short error info here.
  string error = 4;
}

// A single discovered secret or match, typically stored in your DB 'findings'
// table.
message Finding {
  // A unique key for deduplication (e.g., hash of path + secret).
  string fingerprint = 1;
  // The path or location of the found secret (universal).
  string file_path = 2;
  // Line number if relevant (e.g., scanning code).
  int32 line_number = 3;
  // Entire line of text, if captured. (Optional but convenient.)
  string line = 4;
  // The actual match that was found.
  string match = 5;
  // The author's email address.
  string author_email = 6;
  // For ephemeral or extended data: commit hash, message, etc.
  google.protobuf.Struct raw_finding = 7;
}

enum ScanJobStatus {
  SCAN_JOB_STATUS_UNSPECIFIED = 0;
  SCAN_JOB_STATUS_QUEUED = 1;
  SCAN_JOB_STATUS_RUNNING = 2;
  SCAN_JOB_STATUS_COMPLETED = 3;
  SCAN_JOB_STATUS_FAILED = 4;
}

message TaskCredentials {
  oneof auth {
    UnauthenticatedCredentials unauthenticated = 1;
    GitHubCredentials github = 2;
    S3Credentials s3 = 3;
  }
}

message UnauthenticatedCredentials {}

message GitHubCredentials { string auth_token = 1; }

message S3Credentials {
  string access_key = 1;
  string secret_key = 2;
  string session_token = 3; // Optional for temporary credentials
}

enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0;
  TASK_STATUS_IN_PROGRESS = 1;
  TASK_STATUS_COMPLETED = 2;
  TASK_STATUS_FAILED = 3;
}

message TaskStartedEvent {
  string job_id = 1;
  string task_id = 2;
  int64 timestamp = 3; // Unix timestamp in nanoseconds
}

message TaskProgressedEvent {
  string task_id = 1;
  int64 sequence_num = 2;
  int64 timestamp = 3;
  string status = 4;
  int64 items_processed = 5;
  int32 error_count = 6;
  string message = 7;
  bytes progress_details = 8;
  Checkpoint checkpoint = 9;
}

message Checkpoint {
  string task_id = 1;
  int64 timestamp = 2;
  bytes resume_token = 3;
  map<string, string> metadata = 4;
}
